import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;

class Main {
    // Constants
    private static final int PORT = 12345;
    private static final int MAX_CLIENTS = 5;

    // Shared resources
    private static final Map<String, List<Object>> objectMap = new HashMap<>();
    private static final Queue<ClientHandler> waitingClients = new LinkedList<>();
    private static final Set<ClientHandler> activeClients = ConcurrentHashMap.newKeySet();

    // Main method
    public static void main(String[] args) {
        if (args.length == 0) {
            startServer();
        } else {
            int clientId = Integer.parseInt(args[0]);
            startClient(clientId);
        }
    }

    // Server logic
    private static void startServer() {
        // Initialize objects
        initializeObjects();

        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("Server started...");
            while (true) {
                Socket clientSocket = serverSocket.accept();

                ClientHandler clientHandler = new ClientHandler(clientSocket);
                synchronized (waitingClients) {
                    if (activeClients.size() < MAX_CLIENTS) {
                        activeClients.add(clientHandler);
                        new Thread(clientHandler).start();
                    } else {
                        waitingClients.add(clientHandler);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void initializeObjects() {
        List<Object> koty = new ArrayList<>();
        List<Object> psy = new ArrayList<>();
        List<Object> ptaki = new ArrayList<>();

        for (int i = 1; i <= 4; i++) {
            koty.add(new Kot("Kot_" + i));
            psy.add(new Pies("Pies_" + i));
            ptaki.add(new Ptak("Ptak_" + i));
        }

        objectMap.put("koty", koty);
        objectMap.put("psy", psy);
        objectMap.put("ptaki", ptaki);
    }

    private static class ClientHandler implements Runnable {
        private Socket clientSocket;
        private int clientId;

        public ClientHandler(Socket socket) {
            this.clientSocket = socket;
        }

        @Override
        public void run() {
            try (ObjectInputStream in = new ObjectInputStream(clientSocket.getInputStream());
                 ObjectOutputStream out = new ObjectOutputStream(clientSocket.getOutputStream())) {

                clientId = in.readInt();

                out.writeObject("OK");
                out.flush();
                System.out.println("Client ID: " + clientId);
                System.out.println("Client " + clientId + " connected.");

                synchronized (waitingClients) {
                    while (activeClients.size() >= MAX_CLIENTS) {
                        waitingClients.wait(); // Wait until a slot is available
                    }
                    activeClients.add(this);
                }

                while (true) {
                    try {
                        String request = (String) in.readObject();
                        System.out.println("Client " + clientId + " requested: " + request);

                        String key = request.split("_")[1].toLowerCase();
                        List<Object> objects = objectMap.getOrDefault(key, new ArrayList<>());

                        out.writeObject(objects);
                        out.flush();
                        System.out.println("Sent objects of type " + key + " to client " + clientId + ": " + objects);
                    } catch (EOFException | SocketException e) {
                        break;
                    } catch (ClassNotFoundException | IOException e) {
                        e.printStackTrace();
                    }
                }
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
            } finally {
                synchronized (waitingClients) {
                    activeClients.remove(this);
                    if (!waitingClients.isEmpty()) {
                        ClientHandler nextClient = waitingClients.poll();
                        activeClients.add(nextClient);
                        synchronized (nextClient) {
                            nextClient.notify(); // Notify the next waiting client
                        }
                    }
                }
                System.out.println("Client " + clientId + " disconnected.");
            }
        }
    }

    // Client logic
    private static void startClient(int clientId) {
        try (Socket socket = new Socket("localhost", PORT);
             ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream in = new ObjectInputStream(socket.getInputStream())) {

            System.out.println("Client " + clientId + ": Connecting to server...");
            out.writeInt(clientId);
            out.flush();

            String response = (String) in.readObject();
            System.out.println("Client " + clientId + ": Response from server: " + response);

            if ("REFUSED".equals(response)) {
                System.out.println("Client " + clientId + ": Connection refused. Exiting...");
                return;
            } else {
                System.out.println("Client " + clientId + ": Connected successfully.");
            }

            requestObjects(in, out, clientId, "get_Koty");
            requestObjects(in, out, clientId, "get_Psy");
            requestObjects(in, out, clientId, "get_Ptaki");
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    private static void requestObjects(ObjectInputStream in, ObjectOutputStream out, int clientId, String request) throws IOException, ClassNotFoundException {
        System.out.println("Client " + clientId + ": Requesting " + request);
        out.writeObject(request);
        out.flush();

        try {
            List<Object> objects = (List<Object>) in.readObject();
            System.out.println("Client " + clientId + ": Received " + request + ": " + objects);
        } catch (ClassCastException e) {
            System.out.println("Client " + clientId + ": Error casting received object.");
        }
    }
}

// Object classes
class Kot implements Serializable {
    private String name;

    public Kot(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Kot{name='" + name + "'}";
    }
}

class Pies implements Serializable {
    private String name;

    public Pies(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Pies{name='" + name + "'}";
    }
}

class Ptak implements Serializable {
    private String name;

    public Ptak(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Ptak{name='" + name + "'}";
    }
}
